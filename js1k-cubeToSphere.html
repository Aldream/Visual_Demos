<!doctype html>
<html>
  <head>
		<title>JS1k, 1k demo submission [ID]</title>
		<meta charset="utf-8" />
	</head>
	<body>
		<canvas id="c"></canvas>
		<script>
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
		</script>
		<script>
// "BEAUTIFIED" SOURCE, made from the much dirtier original one (10kB limit here, so to take a look aat the implementation process, or at the tricks used, check my website)

// Maps:
var mapFacesSphere=[], mapFacesCube=[];
var NB_DIVISIONS = 20;
var SIZE = 10;
var RADIUS = SIZE/2;

var wHeight, wWidth; 					// Window dimensions.
var angleYaw = angleHeading = .6; 		// Angles defining the camera orientation
var cameraDistance = 100;				// Camera distance to the origin
var wantMove = 0;						// Pseudo-boolean to know which mode is used (3=moving, 0=displaying)
var refreshPaint; 						// Timer generated by the setInterval to refresh the canvas.


var faceId = 0;
// As previously, we iterate desc. The idea is that for each element we iterate on, we evaluate the faces of the square which as for top-left corner this element. So we don't want to iterate on the last column and last row. We thus start at the previous ones (reason why we decreased newDim by 1):
for (var f = 6; f--;) {
	for (var i=NB_DIVISIONS; i--;) {
		// X --- o	Schema representing the faces extracted from a square. X is the current element.
		// |  \  |
		// o --- o
		for (j = NB_DIVISIONS; j--;) {
			for (k=2;k--;) { // We iterate 2 times for each square in order to generate the 2 corresponding triangle-faces.
				var elId = NB_DIVISIONS*i+j;
				var coord = [i/NB_DIVISIONS*SIZE-RADIUS,j/NB_DIVISIONS*SIZE-RADIUS, RADIUS*(1-2*(f%2))];
				// We store each face information into an array [V1.X, V1.Y, V1.Z, V2.X, V2.Y, V2.Z, V3.X, V3.Y, V3.Z, color]:
				mapFacesSphere[faceId] = [];
				mapFacesCube[faceId] = [];
				mapFacesCube[faceId].push(coord[f%3], coord[(f+1)%3], coord[(f+2)%3]);
				
				var x = coord[f%3], y = coord[(f+1)%3], z = coord[(f+2)%3];
				var dist = Math.sqrt(x*x+y*y+z*z);
				mapFacesSphere[faceId].push(
					// 1st vertex
						x/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist),
						y/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist),
						z/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist));
				coord = [(i + k)/NB_DIVISIONS*SIZE-RADIUS, (j + 1-k)/NB_DIVISIONS*SIZE-RADIUS, RADIUS*(1-2*(f%2))];
				mapFacesCube[faceId].push(coord[f%3], coord[(f+1)%3], coord[(f+2)%3]);
				
				x = coord[f%3], y = coord[(f+1)%3], z = coord[(f+2)%3];
				dist = Math.sqrt(x*x+y*y+z*z);
				mapFacesSphere[faceId].push(
					// 1st vertex
						x/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist),
						y/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist),
						z/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist));
						
				coord = [(i+1)/NB_DIVISIONS*SIZE-RADIUS, (j+1)/NB_DIVISIONS*SIZE-RADIUS, RADIUS*(1-2*(f%2))];
				mapFacesCube[faceId].push(coord[f%3], coord[(f+1)%3], coord[(f+2)%3]);
				
				x = coord[f%3], y = coord[(f+1)%3], z = coord[(f+2)%3];
				dist = Math.sqrt(x*x+y*y+z*z);
				mapFacesSphere[faceId].push(
					// 1st vertex
						x/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist),
						y/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist),
						z/dist*RADIUS*(dist-RADIUS)*(RADIUS-dist));
				mapFacesSphere[faceId].push(dist);
				faceId++;
			}
		}
	}
}

var Tween = function(a,b,t,m) { return a*t-m*b*(1-t); } 
var T = 0;
var Paint = function(){
	// Clearing the canvas:
	a.fillRect(0, 0, wWidth=c.width=innerWidth-21,wHeight=c.height=innerHeight-21);
	wWidth/=2; // We need the half-dimension of the screen to calculate the screen coordinates of the vertices. Though we won't divide the height, to emphasize it.
	var screenCoordinates = [];
	var m=-Math.cos(angleYaw),w=-Math.sin(angleYaw),o=Math.cos(angleHeading),x=Math.sin(angleHeading); // To avoid repeating the callings.

	var coefTween = (Math.cos(++T/37)); coefTween*=coefTween;
	var sign = Math.sin(T/23);
	for (l in mapFacesCube) {  // Not optimal, but shorter.
		screenCoordinates[l] = []
		for (j = 9;j;) { // For each vertex of the face.
			// 3D projection. See https://en.wikipedia.org/wiki/3D_projection to find the whole linearized formula ans explanations.
			var v=Tween(mapFacesCube[l][--j], mapFacesSphere[l][j], coefTween, sign)-cameraDistance*o+9,
			u=Tween(mapFacesCube[l][--j], mapFacesSphere[l][j], coefTween, sign)-cameraDistance*m,
			t=Tween(mapFacesCube[l][--j], mapFacesSphere[l][j], coefTween, sign)-cameraDistance*w; // Note: we don't multiply u and v by sin(angleHeading), giving thus another degree of freedom to the camera.
			
			// For each face, we store its screen information into an array [P1.dist, P1.X, P1.Y, P2.dist, P2.X, P2.Y, P3.dist, 3.X, P3.Y, color], with dist the depth viewed from the camera:
			screenCoordinates[l].push(z = o*v+ (k=m*u+w*t)*x,(v*x-o*k)/z*wHeight + wHeight,(w*u-m*t)/z*wWidth + wWidth);
		}
		//screenCoordinates[l][9] = mapFacesSphere[8-wantMove][l][9] // We also copy the colors.
		screenCoordinates[l][9] = mapFacesSphere[l][9]
	}
	
	// To draw the mesh, we use the simple Painter's algorithm (which works well in our case, since we don't have overlapping elements): we sort the faces by decreasing depth (we will simply use P2.dist instead of the average) and draw them it this order.
	screenCoordinates.sort(function(H,S,L){return H[3]-S[3]}); // Sorting
			
	for (l in screenCoordinates) // Drawing each face. I had to choose between only stroking the triangles, only filling them, or sacrificing another feature. I found the holes left by only stroking interesting, like a reminder of those which are part of the universe fabric. ;-)
		//a.fillStyle = 
		a.beginPath(a.strokeStyle='hsl('+999*sign*coefTween/screenCoordinates[l][9]+',50%,'+(l/75)+'%)'),
		a.moveTo(screenCoordinates[l][8], screenCoordinates[l][7]),
		a.lineTo(screenCoordinates[l][5], screenCoordinates[l][4]),
		a.lineTo(screenCoordinates[l][2], screenCoordinates[l][1]),
		a.closePath(),
		a.stroke()
	
	refreshPaint=wantMove? setTimeout(Paint,16) : 0; // Either we let the user move freely around the less-detailed landscape by refreshing continuously the canvas, either we let him/her enjoy the view.
};

// Finally, some interactivity:
b.onclick = function() { 		// We change the view mode on click.
	clearTimeout(refreshPaint);
	Paint(wantMove^=3);
}
b.onmousemove = function(H) {	// We tie the mouse position with the camera orientation.
	angleYaw = 2*H.clientX/wWidth;
	angleHeading = 2*H.clientY/wHeight
}
//b.onmousewheel=function(H){
//	cameraDistance+=H.wheelDelta/99} // Not supported by FF, alas...
//b.onkeydown=function(H){
//	cameraDistance+=(H.which==40)-(H.which==38)} // ... so we use the arrows instead. Less elegant, and 6B heavier.
b.onmousewheel=b.onwheel = function(H) { // Cross-browser solution, but too heavy ... --Update: Now we can afford it! \o/
    cameraDistance -= H.deltaY | -H.wheelDeltaY/40;
}
Paint(wantMove^=3);

/*
How to minify the demo? Tricks I learned ...
	- Closure Compiler and JsCrush are your friends
	- Check github.com/jed/140bytes/wiki/Byte-saving-techniques to learn more dirty tricks.
	- Omit "var", noone will mind
	- Inline when possible (don't use variables for 1-char-long const values, limit the number of functions, ...)
	- Limit the size of your const (use string instead of array, 9 instead of 10, ...)
	- Save delimiters by doing stuff within unused function or loop arguments
	- If/else can be replaced by ternary assignations or bitewise operations
	- Use the fact that the operator "=" assigns a value but also returns it
	- Learn operators precedence to get rid of parentheses.
	- To make the best out of JsCrush:
		- Create patterns in your code:
			- Limit the number of variables, and reuse them smartly (ex: if you keep using the variable A for arrays and i for the indices, every expression "A[i]" will be crushed, saving you 3n-7 bytes, with n the number of times this expression appears)
			- Rearrange your expressions to create new pattern, by ordering the symbols appearances (ex: rearrange "m=i*r-9;q=r*j-9;" into "m=i*r-9;q=j*r-9;" to make the pattern "*r-9;" appears)
			- Use exactly same function signatures (take the longest one and assign it to every function)
		- Check the output of Closure Compile beforehand. It may have altered your signatures or symbols arrangements. It also adds a "useless" semicolon at the end of your script.
		- Save 2 bytes by changing the jsCrush bootstrap: replace "for(Y=0;$='CHAR'[Y++];)with(_.split($))_=join(pop());" by "for(Y in $='CHAR')with(_.split($[Y]))_=join(pop());"
	- Adapt your equations to the context to avoid useless operations or steps / Look at the whole picture
*/

/*

// Real code as implemented:
d=[],g=[], D=[], r=R=21,Y=.6
		
// Generating the landscape with various levels of details :
g[T=Z=l=0]=[o=2,4,9,h=8]//.sort(function(){return .5-Math.random()}) // Initial description of our map : a hole, a bump, and some stuff between ...

for(;l<8;){
	i=p = 2*o-1,d[++l] = [], g[l]=[], h /= 2
	for (; i--;)
		for (j=p; j--;
			v=g[l-1][u=o*(i/2|0)+j/2|0], w=i*p+j, g[l][w]=d[l][w] = (i%2?
				j%2? (d[l][w+p]+d[l][w+1]+2*v)/4:(v+g[l-1][u+o])/2:
				j%2? (v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),
			d[l][w]=d[l][w] < 6?6:d[l][w]);
	//o=p,i=--p,
	o=i=p--,i--, // Smaller once jsCrushed
	r/=2,D[l] = []
	for (; i--;)
		for (j = p; j--;) {
			for (k=2;k--; 
				D[l][Z++] = [
					m=i*r-9,
					q=j*r-9,
					d[l][u=o*i+j],
					(i+k)*r-9, // Z%2 = k
					(j+1-k)*r-9,
					z=d[l][u+1+k*p], // u+1+k*p = u+(Z%2)?1:o
					m+r,
					q+r,
					y=d[l][u+o+1],
					x=2+(z-y)/r,
					'hsl('+[99*(7<(y-=x)?1:6<z?7/z:2),32*(6<z?x*2/y:y)+'%',44*(7<y?x:6.04<z?x/4:6<z?x:1-Math.random()/5)]+'%)']);
		}
}
e=function(H,S,L){
	a.fillRect(0, 0, h=c.width=innerWidth-17,r=c.height=innerHeight-21), 
	m=-Math.cos(Z),w=-Math.sin(Z),o=Math.cos(Y),x=Math.sin(Y),d = [], h/=2
	
	for (l in D[8-T]) {
		d[l] = []
		for (j = 9;j;
			v=D[8-T][l][--j]-R*o, u=D[8-T][l][--j]-R*m, t=D[8-T][l][--j]-R*w,
			d[l].push(z = o*v+ (k=m*u+w*t)*x,(v*x-o*k)/z*r + r,(w*u-m*t)/z*h + h));
		d[l][9] = D[8-T][l][10]
	}
	d.sort(function(H,S,L){return H[3]-S[3]})
			
	for (l in d)
		//a.fillStyle =
		a.beginPath(a.strokeStyle=d[l][9]),
		a.moveTo(d[l][8], d[l][7]),
		a.lineTo(d[l][5], d[l][4]),
		a.lineTo(d[l][2], d[l][1]),
		a.lineTo(d[l][8], d[l][7]), // Smaller than closePath once jsCrushed
		//a.fill(),
		a.stroke()
	o=T?setTimeout(e,16):0
};
b.onclick=function(H,S,L){clearTimeout(o),e(T^=3)}
b.onmousemove=function(H,S,L){Z=2*H.clientX/h,Y=2*H.clientY/r}
//b.onmousewheel=function(H,S,L){
//	R+=H.wheelDelta/99} // Not supported by FF, alas...
//b.onkeydown=function(H,S,L){
//	R+=(H.which==40)-(H.which==38)} // ... so we use the arrows instead. Less elegant, and 6B heavier.
b.onmousewheel=b.onwheel=function(H,S,L){
    R-=H.deltaY|-H.wheelDeltaY/40} // Cross-browser solution, but to heavy ... --Update: Now we can afford it! \o/
e(T^=3)

*/

/* Ready to be jsCrushed (1329B to 1023B):
d=[];g=[];r=R=21;Y=.6;g[T=Z=l=0]=[o=2,4,9,h=8];for(D=[];8>l;){i=p=2*o-1;d[++l]=[];h/=2;for(g[l]=[];i--;)for(j=p;j--;v=g[l-1][u=o*(i/2|0)+j/2|0],w=i*p+j,g[l][w]=d[l][w]=(i%2?j%2?(v*2+d[l][w+p]+d[l][w+1])/4:(v+g[l-1][u+o])/2:j%2?(v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),d[l][w]=6>d[l][w]?6:d[l][w]);o=i=p--;i--;r/=2;for(D[l]=[];i--;)for(j=p;j--;){;for(k=2;k--;D[l][Z++]=[m=i*r-9,q=j*r-9,d[l][u=o*i+j],(i+k)*r-9,(j+1-k)*r-9,z=d[l][u+1+k*p],m+r,q+r,y=d[l][u+o+1],x=2+(z-y)/r,"hsl("+[99*(7<(y-=x)?1:6<z?7/z:2),32*(6<z?x*2/y:y)+"%",40*(7<y?x:6.04<z?x/3:6<z?x:1-Math.random()/5)]+"%)"]);}}e=function(f,n){a.fillRect(0,0,h=c.width=innerWidth-17,r=c.height=innerHeight-21);m=-Math.cos(Z);w=-Math.sin(Z);o=Math.cos(Y);x=Math.sin(Y);d=[];h/=2;for(l in D[8-T]){d[l]=[];for(j=9;j;v=D[8-T][l][--j]-R*o,u=D[8-T][l][--j]-R*m,t=D[8-T][l][--j]-R*w,d[l].push(z=o*v+(k=m*u+w*t)*x,(v*x-o*k)/z*r+r,(w*u-m*t)/z*h+h));d[l][9]=D[8-T][l][10]}d.sort(function(f,n){return f[3]-n[3]});for(l in d)a.strokeStyle=d[l][9],a.beginPath(),a.moveTo(d[l][8],d[l][7]),a.lineTo(d[l][5],d[l][4]),a.lineTo(d[l][2],d[l][1]),a.lineTo(d[l][8],d[l][7]),a.stroke();o=T?setTimeout(e,16):0};b.onclick=function(f,n){clearTimeout(o),e(T^=3)};b.onmousemove=function(f,n){Z=2*f.clientX/h;Y=2*f.clientY/r};b.onmousewheel=b.onwheel=function(f,n){R-=f.deltaY|-f.wheelDeltaY/40};e(T^=3)
*/

/* jsCrushed (1021B):
_='dgr=R1;Y=.6;g[T=Z=l=0K[o,4,9,h=8];D8>l;Li=p*o-1;d[++l]hgv==o&iU)+jUw=i*p+j,gwK=(i%2?#*2+	w+p]+	w@]4:(v++oV#+@Vv)+h&Y!=6>?6:Bi=pirDL;k;kDZ++K[m=iq=j	u=o*i+j(i+k)(j@-k)z=	u@+k*pmCqCy=	u+o@x+(z-yr,"hsl("+[99&7<(y-=x)?1:67/z:2!32&6x*2/y:y)+"%",40&7<y?x:6.04x/3:6x:1/5)]+"%)"]}}eNAfillRect(0,0,h=c.widOEWidO-17,r=c.hFEHF-21m=-GZw=-_ZBGYx=_Ydh`Ldj=9;j;vo,um,tw,d.push(z=o*v+(k=m*u+w*t)*x,(v*x-o*kz*rC(w*u-m*tz*h+h)	9K10]}d.sort(return f[3]-n[3]}`d)Style=	9AbegPaO(!AmovI8Q75Q42Q18Q7]!(BT?sete,16):0clickNclearo!$moveNZX/h;YY/r$=b.onNR-=f.dJ|-f.DJ/40};[function(f,nL=--j]-R*]!AlIfor(=[];MaO.i)j=p;j	dg[l-1][u*r-9,D[8-T]};b.on*f.client);-random()=2],--;wheelinAstrokeTimeout(	w]<z?[l]/;e(T^=3))/!),#j%2?(v$mouse&*(@+1Aa.Bo=C+r,E=nerFeightGcos(IeTo(	JeltaYK]=L){N=OthQ	U/2|0V]2:_s(`l  ';for(Y in $='`_VUQONLKJIGFECBA@&$#!	')with(_.split($[Y]))_=join(pop());eval(_)
*/
		</script>
	</body>
</html>
