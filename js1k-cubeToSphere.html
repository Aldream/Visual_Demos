<!doctype html>
<html>
	<head>
		<title>JS1k, 1k demo submission [ID]</title>
		<meta charset="utf-8" />
	</head>
	<body>
		<canvas id="c"></canvas>
		<script>
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
		</script>
		<script>
//	// "BEAUTIFIED" SOURCE, made from the much dirtier original one (10kB limit here, so to take a look aat the implementation process, or at the tricks used, check my website)
//
//	// Maps:
//	var mapFacesSphere=[], mapFacesCube=[];
//	var NB_DIVISIONS = 16;
//	var SIZE = 5;
//	var RADIUS = SIZE/2;
//
//	var wHeight, wWidth; 					// Window dimensions.
//	var cameraDistance = 9;					// Camera distance to the origin
//
//	var GenerateVertex = function(i, j, mC, mS, faceId) {
//		var coord = [i/NB_DIVISIONS*SIZE-RADIUS, j/NB_DIVISIONS*SIZE-RADIUS, RADIUS*(1-2*(f%2))];
//		var x = coord[f%3], y = coord[(f+1)%3], z = coord[(f+2)%3];
//		mapFacesCube[faceId].push(x,y,z);
//		
//		dist = Math.sqrt(x*x+y*y+z*z);
//		mapFacesSphere[faceId].push(
//			// 1st vertex
//				x/dist*RADIUS/**(dist-RADIUS)*(RADIUS-dist)*/,
//				y/dist*RADIUS/**(dist-RADIUS)*(RADIUS-dist)*/,
//				z/dist*RADIUS/**(dist-RADIUS)*(RADIUS-dist)*/);	
//	}
//
//	var faceId = 0;
//	// As previously, we iterate desc. The idea is that for each element we iterate on, we evaluate the faces of the square which as for top-left corner this element. So we don't want to iterate on the last column and last row. We thus start at the previous ones (reason why we decreased newDim by 1):
//	for (var f = 6; f--;) {
//		for (var i=NB_DIVISIONS; i--;) {
//			// X --- o	Schema representing the faces extracted from a square. X is the current element.
//			// |  \  |
//			// o --- o
//			for (j = NB_DIVISIONS; j--;) {
//				for (k=2;k--;) { // We iterate 2 times for each square in order to generate the 2 corresponding triangle-faces.
//					// We store each face information into an array [V1.X, V1.Y, V1.Z, V2.X, V2.Y, V2.Z, V3.X, V3.Y, V3.Z, color]:
//					mapFacesSphere[faceId] = [];
//					mapFacesCube[faceId] = [];
//					GenerateVertex(i,j,mapFacesCube,mapFacesSphere, faceId);
//					GenerateVertex(i+k,j+1-k,mapFacesCube,mapFacesSphere, faceId);
//					GenerateVertex(i+1,j+1,mapFacesCube,mapFacesSphere, faceId);
//					
//					mapFacesSphere[faceId].push(dist);
//					faceId++;
//				}
//			}
//		}
//	}
//
//
//	var T = 0;
//	var Tween = function(a,b,t,m) { return a*t-m*b*(1-t); } 
//	var Pulse = function(x,c,w) { var h=Math.abs(c-x)/w; return h>1?0:1-(3-2*h)*h*h;} 
//	var pulseTans = [];
//	var Paint = function(){
//		// Clearing the canvas:
//		a.fillRect(0, 0, wWidth=c.width=innerWidth-21,wHeight=c.height=innerHeight-21);
//		wWidth/=2; wHeight/=2;
//		var screenCoordinates = [];
//		
//		var coefTween = Math.cos(++T/23);
//		var sign = Math.sin(T/37);
//		var pulseCos, pulseTan = 0;
//		for(var z in pulseTans){
//			pulseTan+=Pulse(pulseTans[z]--,49,49);
//			pulseTans[z]||pulseTans.shift(); // clean, but optional
//		}
//		pulseTan *= pulseTan;	
//		pulseCos = Pulse(T%300,99,99)/2;
//		var m=-Math.cos(T/37),w=-Math.sin(T/37),o=Math.cos(T/23),x=Math.sin(T/23); // To avoid repeating the callings.
//		
//		for (l in mapFacesCube) {  // Not optimal, but shorter.
//			screenCoordinates[l] = []
//			for (j = 9;j;) { // For each vertex of the face.
//				// 3D projection. See https://en.wikipedia.org/wiki/3D_projection to find the whole linearized formula ans explanations.
//				var v=Tween(mapFacesCube[l][--j], mapFacesSphere[l][j], coefTween+pulseCos, sign)+cameraDistance*o*(1-Math.cos(T/37+Math.tan(mapFacesSphere[l][9])*pulseTan))*Math.cos(mapFacesSphere[l][9]*pulseCos),
//				u=Tween(mapFacesCube[l][--j], mapFacesSphere[l][j], coefTween-pulseCos, sign)+cameraDistance*x*m*(1-Math.sin(T/23+Math.tan(mapFacesSphere[l][9])*pulseTan))*Math.cos(mapFacesSphere[l][9]*pulseCos),
//				t=Tween(mapFacesCube[l][--j], mapFacesSphere[l][j], coefTween+pulseCos, sign)+cameraDistance*x*w*(1-Math.sin(T/37+Math.tan(mapFacesSphere[l][9])*pulseTan))*Math.cos(mapFacesSphere[l][9]*pulseCos); // Note: we don't multiply u and v by sin(angleHeading), giving thus another degree of freedom to the camera.
//				
//				// For each face, we store its screen information into an array [P1.dist, P1.X, P1.Y, P2.dist, P2.X, P2.Y, P3.dist, 3.X, P3.Y, color], with dist the depth viewed from the camera:
//				screenCoordinates[l].push(z = o*v+ (k=m*u+w*t)*x,(v*x-o*k)/z*wHeight + wHeight,(w*u-m*t)/z*wWidth + wWidth);
//			}
//			//screenCoordinates[l][9] = mapFacesSphere[8-wantMove][l][9] // We also copy the colors.
//			screenCoordinates[l][9] = mapFacesSphere[l][9]
//		}
//		
//		// To draw the mesh, we use the simple Painter's algorithm (which works well in our case, since we don't have overlapping elements): we sort the faces by decreasing depth (we will simply use P2.dist instead of the average) and draw them it this order.
//		screenCoordinates.sort(function(H,S,L){return H[3]-S[3]}); // Sorting
//				
//		for (l in screenCoordinates) // Drawing each face. I had to choose between only stroking the triangles, only filling them, or sacrificing another feature. I found the holes left by only stroking interesting, like a reminder of those which are part of the universe fabric. ;-)
//			
//			a.beginPath(a.fillStyle = a.strokeStyle='hsl('+[399*coefTween/screenCoordinates[l][9],'50%',l/75*Math.cos(pulseCos/7)]+'%)'),
//			a.moveTo(screenCoordinates[l][8], screenCoordinates[l][7]),
//			a.lineTo(screenCoordinates[l][5], screenCoordinates[l][4]),
//			a.lineTo(screenCoordinates[l][2], screenCoordinates[l][1]),
//			a.closePath(),
//			a.stroke(),
//			a.fill()
//	};
//
//	// Finally, some interactivity:
//	b.onclick = function(){pulseTans.push(99)};
//
//	b.onmousemove = function(H) {	// We tie the mouse position with the camera orientation.
//		angleYaw = 2*H.clientX/wWidth;
//		angleHeading = 2*H.clientY/wHeight
//	}
//	//b.onmousewheel=function(H){
//	//	cameraDistance+=H.wheelDelta/99} // Not supported by FF, alas...
//	//b.onkeydown=function(H){
//	//	cameraDistance+=(H.which==40)-(H.which==38)} // ... so we use the arrows instead. Less elegant, and 6B heavier.
//	b.onmousewheel=b.onwheel = function(H) { // Cross-browser solution, but too heavy ... --Update: Now we can afford it! \o/
//		cameraDistance -= H.deltaY | -H.wheelDeltaY/40;
//	}
//	*/
//	setInterval(Paint,16);

/*
How to minify the demo? Tricks I learned ...
	- Closure Compiler and JsCrush are your friends
	- Check github.com/jed/140bytes/wiki/Byte-saving-techniques to learn more dirty tricks.
	- Omit "var", noone will mind
	- Inline when possible (don't use variables for 1-char-long const values, limit the number of functions, ...)
	- Limit the size of your const (use string instead of array, 9 instead of 10, ...)
	- Save delimiters by doing stuff within unused function or loop arguments
	- If/else can be replaced by ternary assignations or bitewise operations
	- Use the fact that the operator "=" assigns a value but also returns it
	- Learn operators precedence to get rid of parentheses.
	- To make the best out of JsCrush:
		- Create patterns in your code:
			- Limit the number of variables, and reuse them smartly (ex: if you keep using the variable A for arrays and i for the indices, every expression "A[i]" will be crushed, saving you 3n-7 bytes, with n the number of times this expression appears)
			- Rearrange your expressions to create new pattern, by ordering the symbols appearances (ex: rearrange "m=i*r-9;q=r*j-9;" into "m=i*r-9;q=j*r-9;" to make the pattern "*r-9;" appears)
			- Use exactly same function signatures (take the longest one and assign it to every function)
		- Check the output of Closure Compile beforehand. It may have altered your signatures or symbols arrangements. It also adds a "useless" semicolon at the end of your script.
		- Save 2 bytes by changing the jsCrush bootstrap: replace "for(Y=0;$='CHAR'[Y++];)with(_.split($))_=join(pop());" by "for(Y in $='CHAR')with(_.split($[Y]))_=join(pop());"
	- Adapt your equations to the context to avoid useless operations or steps / Look at the whole picture
*/


// Maps:
S=[], C=[],
T = [],
t = Z = Y = F = U=4;
I=Math; J=I.cos; K=I.sin; L=I.tan;
V = function(A, B) {
	v = [A/4-2, B/4-2, 2-4*(f%2)];
	x = v[f%3], y = v[(f+1)%3], z = v[(f+2)%3];
	C[F].push(x,y,z);
	
	d = I.sqrt(x*x+y*y+z*z);
	S[F].push(
		// 1st vertex
			x/d/**(d-R)*(R-d)*/,
			y/d/**(d-R)*(R-d)*/,
			z/d/**(d-R)*(R-d)*/);	
}

// As previously, we iterate desc. The idea is that for each element we iterate on, we evaluate the faces of the square which as for top-left corner this element. So we don't want to iterate on the last column and last row. We thus start at the previous ones (reason why we decreased newDim by 1):
for (f = 6; f--;)
	for (i=16; i--;)
		// X --- o	Schema representing the faces extracted from a square. X is the current element.
		// |  \  |
		// o --- o
		for (j = 16; j--;)
			for (k=2;k--;) // We iterate 2 times for each square in order to generate the 2 corresponding triangle-faces.
				// We store each face information into an array [V1.X, V1.Y, V1.Z, V2.X, V2.Y, V2.Z, V3.X, V3.Y, V3.Z, color]:
				S[F] = [],
				C[F] = [],
				V(i,j),
				V(i+k,j+1-k),
				V(i+1,j+1),
				S[F][9]=d,
				F++;


V = function(A,B) { return A*(R+i)-K(t/47)*B*(1-(R+i)); } 
P = function(A,B) { y=I.abs(B-A)/B; return y>1?0:1-(3-2*y)*y*y;} 
M = function(A,B){
	// Clearing the canvas:
	a.fillRect(0, 0, W=c.width=innerWidth-21,H=c.height=innerHeight-21);
	W/=2; H/=2;
	s = [];
	
	i = J(t/23);
	D = 0;
	for(F in T){
		D+=P(T[F]--,47);
		T[F]||T.shift(); // clean, but optional
	}
	D *= D;	
	R = P(++t%263,97)/2;
	y=-J(Z+t/23),w=-K(Z+t/23),z=J(Y+t/47),x=K(Y+t/47); // To avoid repeating the callings.
	
	for (F in C) {  // Not optimal, but shorter.
		s[F] = []
		for (f = 9;f;
			// 3D projection. See https://en.wikipedia.org/wiki/3D_projection to find the whole linearized formula ans explanations.
			v=V(C[F][--f], S[F][f])+U*(1-J(t/23+L(S[F][9])*D))*J(S[F][9]*R)*z,
			u=V(C[F][--f], S[F][f])+U*(1-J(t/23+L(S[F][9])*D))*J(S[F][9]*R)*x*y,
			r=V(C[F][--f], S[F][f])+U*(1-J(t/23+L(S[F][9])*D))*J(S[F][9]*R)*x*w, // Note: we don't multiply u and v by sin(angleHeading), giving thus another degree of freedom to the camera.
			
			// For each face, we store its screen information into an array [P1.d, P1.X, P1.Y, P2.d, P2.X, P2.Y, P3.d, 3.X, P3.Y, color], with d the depth viewed from the camera:
			s[F].push(N = z*v+x*(k=y*u+w*r),(x*v-z*k)/N*H + H,(w*u-r*y)/N*W + W));

		//s[F][9] = S[8-wantMove][F][9] // We also copy the colors.
		s[F][9] = S[F][9]
	}
	
	// To draw the mesh, we use the simple Painter's algorithm (which works well in our case, since we don't have overlapping elements): we sort the faces by decreasing depth (we will simply use P2.d instead of the average) and draw them it this order.
	s.sort(function(A,B){return A[3]-B[3]}); // Sorting
			
	for (F in s) // Drawing each face. I had to choose between only stroking the triangles, only filling them, or sacrificing another feature. I found the holes left by only stroking interesting, like a reminder of those which are part of the universe fabric. ;-)
		a.fillStyle = a.strokeStyle='hsl('+[397*i/s[F][9],'47%',F/97*J(R/23)]+'%)'
		a.beginPath(),
		a.moveTo(s[F][8], s[F][7]),
		a.lineTo(s[F][5], s[F][4]),
		a.lineTo(s[F][2], s[F][1]),
		a.closePath(),
		a.stroke(),
		a.fill()
}

// Finally, some interactivity:
b.onclick = function(A,B){T.push(97)};
b.onmousemove=function(A,B){Z=A.clientX/W,Y=A.clientY/H}
//b.onmousewheel=function(H,S,L){
//	R+=H.wheelDelta/99} // Not supported by FF, alas...
//b.onkeydown=function(H,S,L){
//	R+=(H.which==40)-(H.which==38)} // ... so we use the arrows instead. Less elegant, and 6B heavier.
b.onmousewheel=b.onwheel=function(A,B){U-=A.deltaY/2|-A.wheelDeltaY/97}

setInterval(M,16);

/*
S=[];C=[];T=[];t=Z=Y=F=U=4;I=Math;J=I.cos;K=I.sin;L=I.tan;V=function(e,g){v=[e/4-2,g/4-2,2-4*(f%2)];x=v[f%3];y=v[(f+1)%3];z=v[(f+2)%3];C[F].push(x,y,z);d=I.sqrt(x*x+y*y+z*z);S[F].push(x/d,y/d,z/d)};for(f=6;f--;)for(i=16;i--;)for(j=16;j--;)for(k=2;k--;)S[F]=[],C[F]=[],V(i,j),V(i+k,j+1-k),V(i+1,j+1),S[F][9]=d,F++;V=function(e,g){return e*(R+i)-K(t/47)*g*(1-(R+i))};P=function(e,g){y=I.abs(g-e)/g;return 1<y?0:1-(3-2*y)*y*y}; M=function(e,g){a.fillRect(0,0,W=c.width=innerWidth-21,H=c.height=innerHeight-21);W/=2;H/=2;s=[];i=J(t/23);D=0;for(F in T)D+=P(T[F]--,47),T[F]||T.shift();D*=D;R=P(++t%263,97)/2;y=-J(Z+t/23);w=-K(Z+t/23);z=J(Y+t/47);x=K(Y+t/47);for(F in C){s[F]=[];for(f=9;f;v=V(C[F][--f],S[F][f])+U*(1-J(t/23+L(S[F][9])*D))*J(S[F][9]*R)*z,u=V(C[F][--f],S[F][f])+U*(1-J(t/23+L(S[F][9])*D))*J(S[F][9]*R)*x*y,r=V(C[F][--f],S[F][f])+U*(1-J(t/23+L(S[F][9])*D))*J(S[F][9]*R)*x*w,s[F].push(N=z*v+x*(k=y*u+w*r),(x*v-z*k)/N*H+H,(w* u-r*y)/N*W+W));s[F][9]=S[F][9]}s.sort(function(e,g){return e[3]-g[3]});for(F in s)a.fillStyle=a.strokeStyle="hsl("+[397*i/s[F][9],"47%",F/97*J(R/23)]+"%)";a.beginPath();a.moveTo(s[F][8],s[F][7]);a.lineTo(s[F][5],s[F][4]);a.lineTo(s[F][2],s[F][1]);a.closePath();a.stroke();a.fill()};b.onclick=function(e,g){T.push(97)};b.onmousemove=function(e,g){Z=e.clientX/W;Y=e.clientY/H};b.onmousewheel=b.onwheel=function(e,g){U-=e.a/2|-e.wheelDeltaY/97};setInterval(M,16);
*/

		</script>
	</body>
</html>
